wa with installation of dynamodb
java -Djava.library.path=./DynamoDBLocal_lib -jar DynamoDBLocal.jar -sharedDb


usage: java -Djava.library.path=./DynamoDBLocal_lib -jar DynamoDBLocal.jar
            [-port <port-no.>] [-inMemory] [-delayTransientStatuses]
            [-dbPath <path>][-sharedDb] [-cors <allow-list>]
 -cors <arg>                Enable CORS support for javascript against a
                            specific allow-list list the domains separated
                            by , use '*' for public access (default is
                            '*')
 -dbPath <path>             Specify the location of your database file.
                            Default is the current directory.
 -delayTransientStatuses    When specified, DynamoDB Local will introduce
                            delays to hold various transient table and
                            index statuses so that it simulates actual
                            service more closely. Currently works only for
                            CREATING and DELETING online index statuses.
 -help                      Display DynamoDB Local usage and options.
 -inMemory                  When specified, DynamoDB Local will run in
                            memory.
 -optimizeDbBeforeStartup   Optimize the underlying backing store database
                            tables before starting up the server
 -port <port-no.>           Specify a port number. Default is 8000
 -sharedDb                  When specified, DynamoDB Local will use a
                            single database instead of separate databases
                            for each credential and region. As a result,
                            all clients will interact with the same set of
                            tables, regardless of their region and
                            credential configuration. (Useful for
                            interacting with Local through the JS Shell in
                            addition to other SDKs)

var AWS = require('aws-sdk');

var config = {
  "apiVersion": "2012-08-10",
  "accessKeyId": "abcde",
  "secretAccessKey": "abcde",
  "region":"us-west-2",
  "endpoint": "http://localhost:8000"
}
var dynamodb = new AWS.DynamoDB(config);

lets see how we can get a ui for it


Need an AWS instance to be used in dynamo db credenditials above.






dynamodb frontend-
http://razorsql.com/download_mac.html


gotta start with this:
http://docs.aws.amazon.com/amazondynamodb/latest/gettingstartedguide/GettingStarted.NodeJs.01.html

{
  "message": "Missing credentials in config",
  "code": "CredentialsError",
  "time": "2017-04-27T07:50:13.537Z",
  "retryable": true,
  "originalError": {
    "message": "Could not load credentials from any providers",
    "code": "CredentialsError",
    "time": "2017-04-27T07:50:13.537Z",
    "retryable": true,
    "originalError": {
      "message": "Connection timed out after 1000ms",
      "code": "TimeoutError",
      "time": "2017-04-27T07:50:13.536Z",
      "retryable": true
    }
  }
}


found it finally
http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html


enable cors:

https://github.com/expressjs/cors



things we want to utilize in this project from starting:

1. Redux, redux developer tools and react hot module reloading with jsx reloading
2. some good orm for dynamodb
3. sass, and all good practices of sass
4. eslint and a fixed style guide.
5. test cases - sinon, mocha, jasmine and enzyme
6. express + sails.


We will need to look thru the use case and think of a good db/model and look thru the use case and have tables and table restraints based on the use cases.
go thru the entire dynamodb nodejs tute and do what he says just to understand what he says- basic CRUD in dynamodb.



from the look of it:

1. the ability to create custom forms and save the format for a person 
2. each person has his hierarchial node and there is a single pojo representing the entire representation of the entire organization 
   2a. how to read csv files in express and develop this POJO from form data and save it in db
   2b. how to derive his relatve position and his permissions from a POJO and what the given user should see

3. publish forms based on hierarchy of organization - (which is a POJO derived from the csv upload in the last step)

4. which person in the hierarchy should see what - think through db inconsistencies - and express.
5. publish reports based on a hierarchial model - do aggregate functions which are customizable and build a ui around it.


NO BOOTSTRAP.
developement starts tomorrow.

a role based ui,
maybe explore sails mvc and how it can help us - 

because the db insertion through plain express script is disgusting.

The main challenge is architecture. maybe we should also go through sailsjs and develop a good POC - which will accomplish everything.
Also use redux with sailsjs and server caching to do this, to present a great architecture.


So for the next 3 days, we think about architechture and sailsjs and algorithms - so that everything is on a certain path that you decide.

If we can decode the whole POC - all the articulate points of functionality based on the use case document - build the basic stuff first.

I also need a whiteboard first - more than everything.


every user has his level and we will have to re-think the UI so that it is optimized. distill the use case document into a UI in a whiteboard - and connect into a db model diagram.



Today:
1. complete the node js - dynamodb concept tute
2. build a file uploader in node and connect it to a UI in react.




first we need to get really well with db:

{  
   "Table":{  
      "AttributeDefinitions":[  
         {  
            "AttributeName":"ID",
            "AttributeType":"N"
         }
      ],
      "TableName":"Names", 
      "KeySchema":[  
         {  
            "AttributeName":"ID",
            "KeyType":"HASH"
         }
      ],
      "TableStatus":"ACTIVE",
      "CreationDateTime":"2017-04-27T15:46:17.359Z",
      "ProvisionedThroughput":{  
         "LastIncreaseDateTime":"1970-01-01T00:00:00.000Z",
         "LastDecreaseDateTime":"1970-01-01T00:00:00.000Z",
         "NumberOfDecreasesToday":0,
         "ReadCapacityUnits":10,
         "WriteCapacityUnits":10
      },
      "TableSizeBytes":156,
      "ItemCount":4,
      "TableArn":"arn:aws:dynamodb:ddblocal:000000000000:table/Names"
   }
}

CRUD operations in dynamodb - simply create params object.

var params = {
    TableName:table,
    Key:{
        "year": year,
        "title": title
    },
    UpdateExpression: "remove info.actors[0]",
    ConditionExpression: "size(info.actors) > :num",
    ExpressionAttributeValues:{
        ":num":3
    },
    ReturnValues:"UPDATED_NEW"
};





lets use express-mvc-generator and use it to only do CRUD with dynamo.

another good idea can be to use restful api's and call them from react code.
https://scotch.io/tutorials/build-a-restful-api-using-node-and-express-4

lets try to update with condition on a non primary key

db structure - always use camelcase for all name and attribute names



userDetails:

userId
firstName
lastName
email
role
bu
team
archiveRoles : [
  {role:, bu:, team: date:},
]
createdOn
updatedOn
updatedBy


1. setup generator mvc in server - make it work and push the code -
now!





2. do sample csv upload and make it to populate table
3. return the inserted data in the react view to create an edit view -  
which will take the new data from form, the old data persisted in object model
and pass it to update service - 
get the old role, bu and team, updatedOn, archiverole - and the new role info
build a new archiverole with it - 
and then make an insert - with the formData and the new archiveRole.


the question is can we update an entire array - lets see - with a new array



use mass upload for create a large set of users -
and use ui with specific rows for updating



http://blog.e-zest.com/how-to-handle-file-upload-with-node-and-express-4-0/
and
multer



console.log(req.file);


{ fieldname: 'data',
  originalname: 'sample-1.csv',
  encoding: '7bit',
  mimetype: 'text/csv',
  destination: './../uploads/',
  filename: 'cf4d99874b8f03b7c872c548a54238f8',
  path: '../uploads/cf4d99874b8f03b7c872c548a54238f8',
  size: 97 
}


so i have the file and it's api - now need to read it and create rows from it.
http://stackoverflow.com/questions/32678325/how-to-import-bulk-data-from-csv-to-dynamodb



var fs = require('fs');
var parse = require('csv-parse');
var async = require('async');

var csv_filename = "YOUR_CSV_FILENAME_WITH_ABSOLUTE_PATH";

rs = fs.createReadStream(csv_filename);
parser = parse({
    columns : true,
    delimiter : ','
}, function(err, data) {

    var split_arrays = [], size = 25;

    while (data.length > 0) {
        split_arrays.push(data.splice(0, size));
    }
    data_imported = false;
    chunk_no = 1;

    async.each(split_arrays, function(item_data, callback) {
        ddb.batchWriteItem({
            "TABLE_NAME" : item_data
        }, {}, function(err, res, cap) {
            console.log('done going next');
            if (err == null) {
                console.log('Success chunk #' + chunk_no);
                data_imported = true;
            } else {
                console.log(err);
                console.log('Fail chunk #' + chunk_no);
                data_imported = false;
            }
            chunk_no++;
            callback();
        });

    }, function() {
        // run after loops
        console.log('all data imported....');

    });

});
rs.pipe(parser);



done - now comes the easy part.

[ 'firstName', 'lastName', 'email', 'role', 'bu', 'team' ]

email
firstName
lastName
role
bu
team
archiveRoles : [
  {role:, bu:, team: date:},
]
createdOn
updatedOn
updatedBy

var getParams = {
    TableName: "Names",
    ProjectionExpression: "userId",
    Limit:1,
    ScanIndexForward:false
}

or else just make the email as primary key -



[ 'prabhas.joshi@timeinc.com',
  'Prabhas',
  'Joshi',
  'SDE-2',
  'TECH',
  'ECOMProd' ]



  now to create a editable table component for editing csv data

  archiveRoles



Lets try to create a generic component - which can be used for other tables also:

pass headers and array to display as props

1. display a table




Items to do:
1. add support for multiple field filter selection in grid.
done!


2. add support to update - do mass update - this is a major change.
- services part remaining - lets write a generic service to do this for multiple object array


3. add react-router on main page

4. make the primary key as employee-id on userDetails table and add a updatedBy field- make edits to the component so that primary key will be displayed and never modified.

5. start the userRelation object - which will store the employeeId and supervisorId - 
the ui should allow for all objects in userDetails to be taken and then define a supervisor for them- which shud give a drop down for supervisor.





So we've hit a wall - this combination of filtering and updating is causing a bug.

const bodyJSX = filteredData.map((v,i) => {
      return <tr key={i}>
        {header.map((v1,i1) => {
          return <td key={i1}><EditableField value={v[v1]} pk={v[pk]} fieldName={v1} updateParentGrid={this.updateDataCopy} /></td>
        })}
      </tr>
    });

This bug is completely gone now i think.
lets now write the service which should be pretty easy.

then make employee id as primary key, and make change to UI and services.

[{"userLevel":"Manager","bu":"TECH","till":"Mon May 08 2017 13:24:58 GMT+0530 (IST)","from":"Mon May 08 2017 13:24:09 GMT+0530 (IST)","team":"ECOMProd"},{"userLevel":"Manager","bu":"TECH","till":"Mon May 08 2017 13:25:18 GMT+0530 (IST)","from":"Mon May 08 2017 13:24:58 GMT+0530 (IST)","team":"ECOMProd2"}]




done!

lets add routing.
done.


now to the more complex part:

1. make employee id as primary key in userDetails table - change across services and UI.
-now

done
- in the UI - you will not be able to edit the primary key - nor will we send it back in the update query.
done!


but first - make empId as a number and then use lodash to sort it before displaying it.
- done - now loading sorted data.


- on services end - if you insert into userDetails table- you will also insert into userHierarchy table
- now!

but we also need some other fields to store the hierarchyHistory:

so we need:

empId,
supervisorId,
hierarchyArchive,
createdBy,
updatedBy,
createdOn,
updatedOn

yes thats what we need.


2. on services end - any new person added - will also make an entry in the userHierarchy table - with the employee id and supervisor Id (which will be blank initially)
-now.

-done!



- now to pull this data and show it in a ui of form gird - 

1. pull all the manager mapping - sort them.
2. pull all the userinfo - only names and empId and create some mapper object


3. make a new component for mapping managers - no csv upload for manager mapping- just an update statement and storing the archive just like user data.

4. once the table is ready - write logic to make the tree.




  insertHierarchyObject.Item.supervisorId = -1;
        insertHierarchyObject.Item.hierarchyArchive = [];
        insertHierarchyObject.Item.createdBy = createdBy;
        insertHierarchyObject.Item.createdOn = now.toString();
        insertHierarchyObject.Item.updatedBy = createdBy;
        insertHierarchyObject.Item.updatedOn = now.toString();


We need to do this:


1. change the template to include the manager information.

2. in case of a csv upload - dont overwrite - the rows - see if the row is present and if it is  - write to it's archive. 
I want to use memcache- to a cache of the table whenevere there is an insert or update shift the archive creation to server side.

3. in case of an insert or an update - write the archive roles also if it is already present

for update - lets not shift any code, 
lets write it for an insert - first we need to get all the employee id's present in the system and build a cache of this. 


if payload wants to clear the cache - then delete it.

cache will be like this:

 

Current issues which are pending:

1. no refresh of table when loading data-  check this - done

2. employee id search is not working in search- done

3. add - manager fields in the template - manager employee id, name and email id -
now!

lets change the template
done


lets add the corresponding id's on the other table.
- done!



4. test the archive feature on data upload.
now!







if(line.indexOf('empId') === -1) {
                    asyncTask.push((callback) => {
                        let insertHierarchyObject = userHierarchy.insertSchema;
                        insertHierarchyObject.Item = {};
                        insertHierarchyObject.Item.empId = parseInt(line[0]);
                        insertHierarchyObject.Item.managerEmpId = parseInt(line[7]);
                        docClient.put(insertHierarchyObject, (err, data) => {
                            if (err) {
                                console.log('error in inserting hierarchy');
                                console.log(JSON.stringify(err));
                            }

                            //console.log('successfully inserted hierarchy');
                            callback();
                        });
                    });
                }


if (line.indexOf('empId') === -1) {
          asyncTask.push((callback) => {
            console.log(line);
            callback();
            /*let insertHierarchyObject = userHierarchy.insertSchema;
            insertHierarchyObject.Item = {};
            insertHierarchyObject.Item.empId = parseInt(line[0]);
            insertHierarchyObject.Item.managerEmpId = parseInt(line[7]);
            docClient.put(insertHierarchyObject, (err, data) => {
              if (err) {
                console.log('error in inserting hierarchy');
                console.log(JSON.stringify(err));
                
              } else 
                console.log('successfully inserted hierarchy');
              callback();
            }); */    
          });
        }



Lets test the different upload use cases 
so from server side - archiving is not working - lets see why?


but lets do a commit first - done



lets change the services to the actual data.



2 things remaining:

1. the services archiving thingy is not working correctly- done!



2. the tree structure visualization is not working correctly. http://fperucic.github.io/treant-js/ - This is what we need or this http://stackoverflow.com/questions/3923221/are-there-any-better-javascript-org-charts-compared-with-google-org-chart-api



now





after both this, 
study that react-router tute and the react-bootstrap and build some sample pages using react-bootstrap and check it in - based on the flow - to hell with the tab bar. 










I think Im going to use:
http://visjs.org/docs/network/ for now- as it has support for react js



maybe we insert, and see how it goes.
and create a tree - how is it going to look- lets find out.
done!



Also add test dummy bu's to build the 3 drop downs:
lets assume anyone can have any BU.


and will be based out of a random number.

and add vlookup for BU.

BU1, BU2, BU3, BU4, BU5

=VLOOKUP(G2,map!$I$2:$J$6,2,FALSE)

done!

now, include the BU as a part of the upload.

now we will have to write some server side cache tables which will store all the necessary hierarchy.
and make just 1 request for data, when the app loads and share it - not make it for every component.






So first -


lets build a new test data sheet.



<form encType="multipart/form-data">
  <div>
    <span>Upload Data with CSV Template</span>

    

    <input type="button" value="Upload" onClick={this.submitFile} class="uploadFlie"/>
  </div>
</form>

<form encType="multipart/form-data">
  <div>
     <span>Upload Data with CSV Template</span>
    <input ref="fileData" type="file" name="org2" accept=".csv" />
    <input type="button" value="Upload" onClick={this.submitFile} class="uploadFlie" />
  </div>
</form>



<form encType="multipart/form-data">
  <div>
     <span>Upload Data with CSV Template</span>
    <label class="btn btn-default btn-file browseFile">
      Browse <input ref="fileData" type="file" name="org2" accept=".csv" class="hideButton"/>
    </label>
    <input type="button" value="Upload" onClick={this.submitFile} class="uploadFlie" />
  </div>
</form>







changes to style of the graph


Next steps:

1. implement roles and reduce request for data - do just once on app load and use it for every component- later!


2. create a service to return an object:



[{
  "TECH":[{"1":[2,3,4]},{"21":[33,45]}]
},{
  "BU2": [{"5":[6,7,8]}]
}]




let's not overcomplicate the bu thing and not assign an id to it nor create a new mapping table for BU.
but lets create a manager to bu mapping table- and everytime we add an employee to manager mapping we will need to add a manager to BU mapping also.

Maybe we will need to create a new version of the data - so that all those managers who are not present as an employee itself will not be treated as valid.

lets do this.


when the request is recieved,

see if the userDetails cache is present, if not build it, otherwise use it to create the custom object that we need:


"empId": {object of the employee, his manager empId}.

we basically need all the managers and their bu's.
so we create the above object and then we can

once we have this object - we can easily do the above calculation.

done.




now how to build this object from this object.


[{
  "TECH":[{"1":[2,3,4]},{"21":[33,45]}]
},{
  "BU2": [{"5":[6,7,8]}]
}]


lets start  by sending a request.


so get the nested map only once the employee map is present in the server.


and the employee map.


Q.all([queryConfig(),queryTechConfig(), queryWaves()])








3. do create forms for admins



new tab - to push forms - for admin roles.
1. select BU drop down  + choose everyone under this BU checkbox
2. selec Manager drop down (based on BU) + choose everyone under this manager
3. Multi select user drop down (based on everyone under the chosen manager)



for mail functionality
Arun Nair - check with



So there is some issue that the clicking on checkbox is not making it disabled or not disabled - will fix this later tomorrow morning.


first lets build that hierarchy object in the cache.


lets find a managable tree and set all the bu for it to be the same.



Mega enhancement for later

1. request data once and pass as props to all the tab components. and when there is an update- request for data again.

2. Maybe we can explore to find a nested graph, n-level hierarchy structure later - but lets just proceed now to show them the initial functionality. maybe we can settle on 2 or 3 level managers.





we can now start building this object:


{
  "TECH": {"1":[2,3,4], "5":[6,7]}
  "BU1": {"34":[55,66]}
}


now find the top level managers - whose value is zero and create keys in the respective BU's.




[ 32,
  103,
  1175,
  242,
  582,
  1069,
  58,
  1109,
  690,
  985,
  356,
  1017,
  470,
  19,
  931,
  836,
  20,
  1116,
  70,
  99,
  1031,
  615,
  1154,
  458,
  367,
  735,
  287,
  467,
  61,
  578,
  988,
  12,
  575,
  968,
  1038,
  179 ]

We may have to use some other logic to find the top level managers - but for now it's okay.


{
  "TECH": {"1":[2,3,4], "5":[6,7]}
  "BU1": {"34":[55,66]}
}



now comes the tough part.

from a top level manager id - find all the employees under him till you reach the leaf node.
lets see the hierarchy data.

we will need a recursive function


which takes the mapping object and returns an array of integers.


function findEmployeesOf(x) {
  var i,y =[];
    for (i in map){
       if(map[i] === x) {
          y.push(i)
        }
    }
    return y;
}


function findAllEmpBelowSeed(x) {
  var all = [],temp;
  var empBelow = findEmployeesOf(x);
  if(empBelow.length === 0) {
    return false;
  }

  else {
    all = all.concat(empBelow);
    empBelow.forEach((v,i) => {
      temp = findAllEmpBelowSeed(parseInt(v));
      if(!!temp) {
         all = all.concat(temp);
      }
    });
  }
  return all;
}


done!
awesome!


there shud be no repetition of managers:



{ BU5: 
   { '99': [],
     '103': [],
     '242': [],
     '458': [],
     '615': [],
     '836': [],
     '1109': [] },
  BU2: { '19': [], '690': [], '988': [], '1069': [], '1116': [] },
  BU4: 
   { '12': [],
     '20': [],
     '575': [],
     '735': [],
     '968': [],
     '985': [],
     '1017': [],
     '1154': [] },
  BU1: 
   { '179': [],
     '356': [],
     '467': [],
     '470': [],
     '582': [],
     '931': [],
     '1038': [] },
  BU3: 
   { '32': [],
     '58': [],
     '61': [],
     '287': [],
     '367': [],
     '578': [],
     '1031': [],
     '1175': [] },
  TECH: { '70': [] } }



non admin

approvals
reports
action-items










done- now lets build the UI around it and see if we get the objects correctly in UI.


maybe we shud put everyone in 1 bu - but we really dont care about the BU 



so lets make the drop down as multi select.


so instead of storing the actual innerHTML of the form
just store something else as the formvalue
 like true




send an appropriate response from the send form tab like:

{
  sendToType:"bu" | "manager" | "employees",
  bu:"buname",
  "managerId":"",
  "employeearray":[],
  formId:,
  needsApproval:true | false
}

first make that multi select.




<select class="form-control selectStyle" disabled={employeeDisabled}>
          <option value="">Please select employees</option>
          {empJsx}
</select>


<Select multi joinValues value={this.state.value} placeholder="Select your favourite(s)" options={fruits} onChange={this.handleSelectChange} />






lets just assume there is one form. and once we get the data from, we populate the form-publish table.



now to write an initialize service on load and get all the data at once.
and if the role matches and name is present in the publish table show the form.
nothing big for now.


admin:
1. will see the create form page
2. report page of all users



managers:
form filling page
report page from users below them


users:
form filling page.



major updates listing coming after the prod work.

Here they are:




1. Admin role - the most difficult thing

All drop downs are multi select.
Add checkbox for sending form to the whole organization at the top
Add an extra search based drop down to add a specific user, also add a plus button to include multiple such people


Role based:
there is no managers, there is only admin and non admin
Admins- can create custom forms, and send them to various people
Users - can fill forms, approve forms for people below them and see reports for forms filled below them.


Report charts:
People who are manager above some people will be able to see data filled by those people and also the consolidated reports- doing summation over some field in form.


History:
All users will be able to see the data filled by them on certain forms in history tab.







first -



1. search for a good multi select drop down.

a multi select drop down  + a checkbox - which will send to all the immediate child - and so the drop down below will be disabled

then these values are validated and the new set of values are calculated 
and a drop down is appended - with the newly calculated.


getting the selected values


so I've found it - lets transform it into newer code and study it.
done.



or maybe create a container component which keep creating the dependent arrays and then pass it to an inner dumb component to create the select.

and then use that hierarchy map and the top managers under the bu to create this interface.



Lets call this a new component called - HierarchySelect


Now to get the data for each drop down we need 2 objects:

1. top level managers under each BU - which is easy.
2. the hierarchy object - which is already there.

Let

First we need:


1. entire timeInc checkbox


so now, we test if there can be 2 drop downs which can co exist without touching each other.



maybe find some other way to find on whom the focus has happened


dont rely on events,

lets rely on calculation.
done!

will have to rely on edge cases for when both menus are fully erased.


maybe we will have to find out some inner that has happened.

some sort of internal event handle. but it's better than what it is.

maybe we can do perfect string matching for all the comma separated array of



some edge cases are still remaining - but i think we are really set, maybe we can find some internal event based thing for the select drop down by studying it's internal thingy.

but it seems bug free because if only 1 option is left - thats the edge case. we can check later.
when u delete the last option - it returns "" as the value.

so now it shud be a piece of cake. 

will code the rest tomorrow -

all your dynamodb data is stored in a file like
YOURKEY_sa-east-1.db

and this can be imported in the localhost:8000/shell
the javascript shell for dynamo db
by choosing this file. so lets create a table from server and then import that table.



The test can we do is - if we create a table from the UI - can we use it incode.


build the hierarchy drop down.

so we have a close event - in case of removing options - we can check from there which one was closed.


maybe events dont apply to Select - maybe they apply to createable
<Select multi simpleValue disabled={disabled} value={value} placeholder={placeholder} options={options} onChange={onC} />
<Select multi simpleValue disabled={disabled} value={value} placeholder={placeholder} options={options} onChange={onC} />




so this bug can't be fixed for now. we will search for a solution later - for now. 

lets start with completing the component.


we will have to think of some event programming to do this. but 


initialize for the hierarchy select

1. top level managers under each BU - which is easy.



2. the hierarchy object - which is already there.




<input type="checkbox" class="form-control margin-top-10 notificationCheck" value="on">





{ BU5: [ 103, 242, 1109, 836, 99, 615, 458 ],
  BU2: [ 1069, 690, 19, 1116, 988 ],
  BU4: [ 985, 1017, 20, 1154, 735, 12, 575, 968 ],
  BU1: [ 582, 356, 470, 931, 467, 1038, 179 ],
  BU3: [ 32, 1175, 58, 1031, 367, 287, 61, 578 ],
  TECH: [ 70 ] }



      {
        disabled:false,
        value:[],
        placeholder:'Select something',
        options:[
          { label: 'Chocolate', value: 'chocolate' },
          { label: 'Vanilla', value: 'vanilla' },
          { label: 'Strawberry', value: 'strawberry' },
          { label: 'Caramel', value: 'caramel' },
          { label: 'Cookies and Cream', value: 'cookiescream' },
          { label: 'Peppermint', value: 'peppermint' },

        ],
        shudContainCheckbox:true
      }

we will improve the programming for which later on - or maybe find some other option - but for now we can just complete this thing.




so hierarchy map is like this:


  '1345': 1175,
  '1346': 1175,
  '1347': 12,
  '1348': 1175,
  '1349': 1175,
  '1350': 1175,
  '1351': 1175,
  '1352': 1175,
  '1353': 1175,
  '1354': 1175,
  '1355': 1175,
  '1356': 1175,
  '1357': 1175,
  '1358': 1175,
  '1359': 1175,
  '1360': 22,
  '1362': 1175,
  '1364': 305,
  '1365': 1175,
  '1366': 1175,
  '1367': 1175,
  '1368': 1175,
  '1370': 1175,
  '1372': 1175,
  '1373': 0,
  '1375': 1175,
  '1386': 1175,
  '1387': 1175,
  '1393': 1069,
  '1395': 1175,
  '10105': 42,
  '10110': 470 }


so on clicking of a checkbox - the ones below that will be automatically disabled.

onChange of an option of a top option,


formPublish object


{
  
  type:"immediate-child" | "everyone" | "specific"
  isBu: true | false
  nodes:[]
  extra:[]

  formId : 1
  requireApproval

}

insert a row in form publish table.

deciding what form to display from the form structure table.


{ type: 'everyone', formId: '1', requireApproval: true }

{ type: 'specific',
  nodes: [ '293' ],
  extras: '242',
  formId: '1',
  requireApproval: true }




{ type: 'immediate-child',
  isBu: true,
  nodes: [ 'TECH', 'BU5' ],
  extras: '',
  formId: '1',
  requireApproval: true }




  improve the cross caching later.
  for now it's working.


  now we need to create a form structure table - which will save the form as json and create a component to read this table and then render a form and also gets it's id.

  Once we have the id - we need to send the data back to a datastore table


  with:

  some primary key
  empId
  formId
  formValues



so lets just create a simple form from json using this component
now.
done.

I dont want a lot of things.

Lets just now create a table and save some forms into it.


call it formStructure.

key is hash formId - number.

lets create the table.
done


lets create 3 forms with some different text fields.

onSubmit handle we will write later.
  

const schema = {
  title: "Fill Weekly hours",
  type: "object",
  required: ["hours"],
  properties: {
    hours: {type: "number", title: "Hours", default: "8"}
  }
};



const schema3 = {
  title: "Fill personal Information",
  type: "object",
  required: ["name","age"],
  properties: {
    name: {type: "string", title: "Name", default: "enter name"}
    age: {type: "number", title: "Age", default: "enter age"}
  }
};


[ { formId: 2,
    structure: 
     { title: 'Fill Weekly hours',
       type: 'object',
       required: [Object],
       properties: [Object] } },
  { formId: 1,
    structure: 
     { title: 'User Form',
       type: 'object',
       required: [Object],
       properties: [Object] } },
  { formId: 3,
    structure: 
     { title: 'Fill personal Information',
       type: 'object',
       required: [Object],
       properties: [Object] } } ]


lets add them to the table and write a complete action required tab for the user then commit.


lets re-write the initialize service





now we have a valid entry on publishForm -
lets scan it and get it's output:

[ { formId: 2,
    approval: false,
    empArray: 
     [ '156',
       '293',
       '350',
       '351',
       '375',
       '517',
       '566',
       '576',
       '645',
       '750',
       '794',
       '795',
       '799',
       '817',
       '850',
       '874',
       '1209',
       '1232',
       '233',
       '248',
       '360',
       '365',
       '366',
       '393',
       '398',
       '435',
       '498',
       '540',
       '616',
       '657' ] },
  { formId: 1,
    approval: true,
    empArray: [ '211', '487', '550', '565', '598' ] },
  { formId: 3,
    approval: true,
    empArray: 
     [ '11',
       '64',
       '111',
       '230',
       '362',
       '388',
       '451',
       '501',
       '505',
       '527',
       '533',
       '545',
       '587',
       '631',
       '633',
       '906',
       '1070',
       '1095',
       '1102',
       '1152',
       '1161',
       '1183',
       '1196',
       '1198',
       '1205',
       '1208',
       '1244',
       '1265',
       '1328',
       '1393',
       '187',
       '808',
       '846',
       '924',
       '937',
       '938',
       '1027',
       '1029',
       '1159',
       '1246',
       '56',
       '297',
       '298',
       '439',
       '484',
       '514',
       '647',
       '654',
       '802',
       '961',
       '1041',
       '1128',
       '1160',
       '1226',
       '1251',
       '1302',
       '755',
       '964',
       '965',
       '1057',
       '1060',
       '1062',
       '1063',
       '1064',
       '1067',
       '1075',
       '1077',
       '1082',
       '1083',
       '1084',
       '1085',
       '1087',
       '1094',
       '311',
       '233' ] } ]


now me and sundar will have common entries


[ { formId: 2, approval: true, empArray: [ '242', '1276' ] },
  { formId: 1,
    approval: true,
    empArray: [ '211', '487', '550', '565', '598', '242', '1276' ] },
  { formId: 3,
    approval: true,
    empArray: [ '737', '959', '1276', '242' ] } ]


Prabhas.Joshi@timeinc.com




component={(props, state, params) => <App appName="My Test App" {...props} />}


<Route path="/userForm" {(props, state, params) => <userForm appName="param" {...props} />}  />



{formStAvailable && <Form schema={formStructure}  onSubmit={log("submit")} onError={log("errors!")} /> }



so the submit button is a part of the form.




lets update the sql tables 





Lets add an extra comment section to each of the forms -

so lets modify the json structure before we show it -
done!

now we have to write a formSubmit:



make an entry into the formData table


get this object onLoad for an employee:

then modify the data and call put on end service.

empId - PK
data: {
  1:{key value pair}
}


Really have to check out passing props to route - otherwise we are doing a lot of unnecessary calls.
will check this today.



updating the data:


var table = "Movies";

var year = 2015;
var title = "The Big New Movie";

// Update the item, unconditionally,

var params = {
    TableName:table,
    Key:{
        "year": year,
        "title": title
    },
    UpdateExpression: "set info.rating = :r, info.plot=:p, info.actors=:a",
    ExpressionAttributeValues:{
        ":r":5.5,
        ":p":"Everything happens all at once.",
        ":a":["Larry", "Moe", "Curly"]
    },
    ReturnValues:"UPDATED_NEW"
};

console.log("Updating the item...");
docClient.update(params, function(err, data) {
    if (err) {
        console.error("Unable to update item. Error JSON:", JSON.stringify(err, null, 2));
    } else {
        console.log("UpdateItem succeeded:", JSON.stringify(data, null, 2));
    }
});


now to start building the new update object.



Let's insert something into formData.

I think we shud write a map for formData and not do all this in react. it's not good.



only show the forms for which data has not been filled - in the select drop down.


{ empId: '1276',
  formId: '3',
  data: { name: 'Prabhas Joshi', age: 28, comments: 'order food' } 
}



lets test.




lets do a scan of the formData table.


now we can do end to end testing.


Lets delete  and create
formPublish and formData and
then test.


now we need to show the data to the guys who submitted the data and create an approval workflow into reports- which will definitely be later.




Lets clean up the tabs which we dont need - done





how to create an approval workflow.


we will need to re-create the entire form with the data values
and this time the submit will add an approved:true flag to the the specific form in form data table.


Let's output the formdata table.


lets fill 2 forms.



[  
   {  
      "empId":1276,
      "fData":{  
         "1":{  
            "title":"some title",
            "done":false,
            "comments":"some concern"
         },
         "2":{  
            "hours":9,
            "comments":"I had a sick leave on thursday"
         }
      }
   }
]



Let's create a new tab for approvals.

we need a cache of publishForm - so that we can find out the approval form array for that guy.





we need 3 way of approval status for each form to be saved along with the formdata

sent_for_approval.
approved
not-approved

based on this status we either show the form again or we say it is approved and dont show the form and just say that it is approved.



 { formId: 2, approval: true, empArray: [ '242', '1276' ] },
  { formId: 1,
    approval: true,
    empArray: [ '211', '487', '550', '565', '598', '242', '1276' ] },
  { formId: 3,
    approval: true,
    empArray: [ '737', '959', '1276', '242' ] } ]



hierarchy:
'1345': 1175,
  '1346': 1175,
  '1347': 12,
  '1348': 1175,
  '1349': 1175,
  '1350': 1175,
  '1351': 1175,
  '1352': 1175,
  '1353': 1175,
  '1354': 1175,


if he is the manager of 2 guys who has the same form,

we need:

1. empId and formId - getting passed correctly.


but only need to show the approvals - 
by finding what is the approval status.

so lets initially while filling pass - sent for approval




no we need the flag.

lets just get the initial data - if the user has filled the form or not.


so now we need to see if the approval flag is getting set in formdata or not.
getting set

so now we need the



now we need to show the approver:

all the forms for which data has been filled and is present in his approver forms list:





Lets try this with neetu gupta.

and see the 2 objects which we are getting.




now we need to fetch the formStructure and display the form - read only with 2 buttons



accept and deny




approvalForms:
Array[10]
0:
{…}
empId:
"211"
formId:
1


initialFormData:
{…}
598:
{…}
3:
{…}
1276:
{…}
1:
{…}
comments:
"some concern"

done:
false
title:
"some title"
2:
{…}
approval:
"sent-for-approval"
comments:
"this is filled again"
hours:
180



now we create a read only form, with 2 buttons on the end:

Accept and decline 
lets do this - which will call a service and update the fData.


Lets delete and re-create the tables and then see what happens



I really think i shud take a backup
- lets do this!
done



once the demo is over we can start with completing the approval workflow.



and pass prop like this:

<Route path="/dynamicform" exact render={() => <DynamicForm testprop="some_prop" />}  />






Now to minimize get requests, we shud do all the create a big state object on the Layout component and then pass the respective thing as prop - after the demo.


or maybe we can write some service calls for accept and decline




i dont want to move the get requests right now.
will do this later.








lets fill 2 forms.





I think we shud also mention the approver emp id so that we dont have to track that.


{ empId: '598',
  formId: 1,
  approvalStatus: 'approved',
  approver: '70' }


for a user - show all forms status: which do not have an approval field, or which have rejected approval field or if approved - say that the form has been approved -

for a manager - only show forms which are not-approved or sent-for-approval

lets fill a new form data.


now we can do different status based on approval status.





now have to write on user end.


I think we shud delete formPublish and formData and test again.


I think we need a 4th approval category called:

"resubmitted"


what if he rejects and she fills again.


{ '3': 
   { name: 'gareehsma',
     comments: 'reject this - i will fill again after consulting with you.',
     age: 23,
     approval: 'not-approved',
     approver: '70' } 
     }

now this shud show up to greeshma again.




further packages to use:

style jsx
auth0
next 2.0


Today:

take backup.
done.

1. request for data once in layout - then pass it as props to child.
2. cleanup repeated code in the services end.





so lets make a list of components and what data they want:

only basic get request


<Navigation role={role} />  
          <Route path="/userdetail" component={CsvUpload} />
          <Route path="/sendmail" component={SendEmail} />
          <Route path="/orgTree" component={Tree} />
          <Route path="/sendForm" component={NotificationLink} />
          <Route path="/userForm" component={userForm}  />
          <Route path="/dropDownTest" component={multiSelect} />
          <Route path="/hierarchySelect" component={HierarchySelect} />
          <Route path="/dynamicform" exact render={() => <DynamicForm testprop="some_prop" />}  />
          <Route path="/approval" component={Approval} />


Now lets start putting these things as props.

lets do this tomorrow.




caching functions repetition.



re-write these functions:

done

I want to 

1.
complete writing the performance fixes - data common data passing to all tabs

2.
change the ui when stuff happens - and doing backend service changes also by destroying a particular cache and pulling it again to the whole app.

3.
building an old reports tab - which shows the old reports for the user.



#1 - now










componentDidMount(){
    const { data, pk } = this.props;
    
  }
  componentWillReceiveProps(newProp){
    const { data, pk } = newProp;
    
  }


awesome!



let's do

HierarchySelect
http://localhost:8001/getEmployeeMap
http://localhost:8001/getNestedMap


done!


this.initialize();
this.initializeOtherPeople();




employeeForm
http://localhost:8001/initialize
http://localhost:8001/getFormStructures
http://localhost:8001/getInitialData





Approvals:

http://localhost:8001/initialize
http://localhost:8001/getInitialData
http://localhost:8001/getFormStructures
http://localhost:8001/getEmployeeMap




 



now we have to write ui and service updates for update post, 
to define methods to request for a cache that is updated - 
delete the cache after update and then rebuild the cache and 

do visual updates after new props are loaded.


Let's prioritize and remove all the tabs we dont care about:

1. graph
done



also the csv upload feature - doesnt really need to be demoed tomorrow.

So we need to write transition states for:


2. The approval tab.


3. The selector tab.

So once the form is published we shud show a quick message and then return to the original state.
how to do this.

we should probaly use the loading state the spin kit.


      
      dataIndex:[],
      dropDownArray : [],
      additionalPeople:{
        options: [],
        value: []
      },
      submitting:true


I think we have it.

but there is still a problem - this method is affecting the data in other tabs:

publishForm - so we need to refresh the cache and pass it again to other tabs.

Lets see what the service is doing.

we should destroy the publish form cache before we return a response to the UI

so we should call initialize again  - lets test the publish in network tab.


will have to delete and re-create the tables.



test - after publishing form - the bu drop down is created again and in the network tab the initialize is called again.
awesome!
we dont even have to call the repetitive things

We may have to write a better caching layer- but thats the next level of performance fixes-  maybe later.


this one now.
1. The action required tab.




a form which has been sent for approval -
the user shud not be allowed to submit it again and it shud say that it's submitted for approval.

so if the approval property is 

sent-for-approval - 
we shud not show the form.

Lets just fill a new form and then fill it and see what happens.
ok
now we just need to get new initial data when the submit happens and 

we're really close!


I really want to take a backup and then code the rest and test at home.


lets take a backup.

done

Lets  make the approvals dynamic.

lets load some approvals.


LEts try it.

delete tables and test.

done.

2 things
:

1. pass empMap to employee form to show the approver
done.


2. create the report component - show approved and filled forms - Lets create a Reports Component.



all approved forms and all filled forms.


{!submitting && formStAvailable &&
          <div>
          {formDisplay.text && <span>{formDisplay.text}</span>}

          {!formDisplay.plain && 
            <Form schema={formDisplay}  onSubmit={this.handleSubmit} onError={() => console.log('error')} />
          }
          </div>
        }


Lets test with multiple forms.

push 2 forms to same people and then check.



To take it to the next level - 
we need to preserve the state caused by last action - that may be taking it too far -
maybe use redux 


tests remaining:
if we leave the last leaf type employee drop down blank  - will the form be published.
lets test this.

test failed - select different nodes in case of specific.

delete tables and re-create.







I want to make hierarchy selector a little more complex - by providing 2 checkboxes instead of 1:

1. send to all immediate childs of above
2. to send to everyone below the selected values

If both are unselected - and nothing is selected below - send to the selected values.

So refine the service layer and consider everything.


Also I want to move all calculations on the service layer instead of calculating stuff in front end.



Next features - Today.

make it Time Inc india - easy

1. making hierarchy selector awesome - more customizable.
now:

in terms of type we need:


{
  type:"immediate-child" | "everyone" | "specific" | "everyone-below"
  isBu: true | false
  nodes:[]
  extra:[]
  formId : 1
  requireApproval
}

maybe we shud do all calculations on sever end.

at any level, we shud contain both checkboxes.

at one time, you can only select one.
so let's give this 
done

let also give the all property to all the dropdownarray.




in case of specific - the last node with any value is the one.


done - 
lets run some test with the req.body

going well.

Lets write some case for everyone-below



some use cases of payload:

{ 
  type: 'everyone', 
  formId: '2', 
  requireApproval: false 
},
{ 
  type: 'specific',
  isBu: true,
  nodes: [ 'BU5', 'BU2' ],
  extras: '7',
  formId: '1',
  requireApproval: false 
},

{ 
  type: 'everyone-below',
  isBu: true,
  nodes: [ 'BU2' ],
  extras: '11,13',
  formId: '2',
  requireApproval: true 
},

{ type: 'immediate-child',
  isBu: false,
  nodes: [ '103' ],
  extras: [],
  formId: '3',
  requireApproval: true 
},

{ type: 'specific',
  nodes: [ '13' ],
  extras: [],
  formId: '1',
  requireApproval: true 
}



   <->    
<->Done<->
   <->    


We can test on the actual data that is added to the table later with neetu gupta tree.

Making data uploads based on form id and field - 
we can maybe show them a preview of the csv that they should give us and 
do a quick server side validation with error message - if the mapping is incorrect.

We will need a cache of the formStructure table.

So Lets create a new component for the admins.

Upload Form Data

Choose a formId,

See it's preview -> show them the fields that the csv needs to have

Have a csv upload file

And a button

And a status to show when it's successfuly uploaded.

And also for all the entries uploaded -
we will automatically set the approval status to approved - since we dont want the form to show for filling or for rejection flow.

So maybe for reports, we will need to focus only on formData table with approved data.

This will also get the service to reInitialize data after successful csv upload

lets write this damn service!

I should get the formId and then get the.

this is great info:

req.params is populated from the express path (e.g. /hello/:name => req.params.name).

req.files is only for files.

req.body contains the parsed fields that isn't files.



awesome, it's working - now lets quickly write the db logic.



{ fieldname: 'data',
  originalname: 'data-2-post.csv',
  encoding: '7bit',
  mimetype: 'text/csv',
  destination: './uploads/',
  filename: '42dba38425d101d0c2366fb5140fde8b',
  path: 'uploads/42dba38425d101d0c2366fb5140fde8b',
  size: 22 }


{ formId: '1' }


so we have to parse and read the csv,

do an insert in the formData table - 

so create a cache of the formData and use that.

I want to do a select * for formData table.


table:
[  
   {  
      "empId":211,
      "fData":{  
         "3":{  
            "name":"carl",
            "approver":"70",
            "comments":"please approve this form",
            "age":34,
            "approval":"approved"
         }
      }
   },
   {  
      "empId":487,
      "fData":{  
         "3":{  
            "name":"sayantani",
            "approver":"70",
            "comments":"approve",
            "age":32,
            "approval":"approved"
         }
      }
   }
]

cache:
{ '211': 
   { '3': 
      { name: 'carl',
        approver: '70',
        comments: 'please approve this form',
        age: 34,
        approval: 'approved' } },
  '487': 
   { '3': 
      { name: 'sayantani',
        approver: '70',
        comments: 'approve',
        age: 32,
        approval: 'approved' } } }


we might have to insert or we may have to udpate.


[ [ 'empId', 'Hours' ],
[ '1', '9' ], 
[ '2', '18' ] ]

so use the first row to create the insert object



[ 'empId', 'Hours' ]
[ '1', '9' ]
[ '2', '18' ]



now to test this with 3 cases:

1. create a new employee and a new form
2. create a new form for an exisiting employee
3. overwrite the values of an existing employee and an existing form.


{  
      "empId":211,
      "fData":{  
         "3":{  
            "name":"carl",
            "approver":"70",
            "comments":"please approve this form",
            "age":34,
            "approval":"approved"
         }
      }
   }


Lets write these values.

empId, Name, Age


Building a formbuilder.


dont add option to delete fields now - will do later.
and can't add support for drop downs right now.

only 

text-field, 
single-checkbox, 
text-area (for large values)


{  
   "title":"Fill personal Information",
   "type":"object",
   "required":[  
      "name",
      "age"
   ],
   "properties":{
      "name":{  
         "type":"string",
         "title":"Name",
         "default":"enter name"
      },
      "age":{  
         "type":"number",
         "title":"Age",
         "default":"enter age"
      }
   }
}

once i test the flow i can add support for more fields and utilizing the uischema.

this should also get method to refresh the formStructures



maybe a scan with this will work


let findMaxUserId = {
  TableName: "userDetails",
  ProjectionExpression: "userId",
  ScanIndexForward:false
};


lets test!


{ Items: [ { formId: 2 }, { formId: 1 }, { formId: 3 } ],

will ahve to do ascan of formStructure:


[  
   {  
      "formId":2,
      "structure":{  
         "title":"Fill Weekly hours",
         "type":"object",
         "required":[  
            "hours"
         ],
         "properties":{  
            "hours":{  
               "type":"number",
               "title":"Hours",
               "default":"40"
            }
         }
      }
   },
   {  
      "formId":1,
      "structure":{  
         "title":"User Form",
         "type":"object",
         "required":[  
            "title"
         ],
         "properties":{  
            "title":{  
               "type":"string",
               "title":"Title",
               "default":"A new task"
            },
            "done":{  
               "type":"boolean",
               "title":"Done?",
               "default":false
            }
         }
      }
   },
   {  
      "formId":3,
      "structure":{  
         "title":"Fill personal Information",
         "type":"object",
         "required":[  
            "name",
            "age"
         ],
         "properties":{  
            "name":{  
               "type":"string",
               "title":"Name",
               "default":"enter name"
            },
            "age":{  
               "type":"number",
               "title":"Age",
               "default":"enter age"
            }
         }
      }
   }
]

now get the forms in the react view.
done!



lets do a end to end testing!
done!



now lets clear and re-create all the tables.



Lets test the bulk upload.









lets upload this.



so the data upload part is not working correctly.



for 211 carl.



Lets investigate this.



Firstname
Lastname
Over 30



reports over a node.

General use case:

If a form has been published over a node and data has been collected by all below that node, we shud be able to apply a function and get the aggregate value over that node.

The things which can change are:

1. the node-level at which the report has to be fetched

What variations can happen:

All immediate children below the given node
Everyone below the given node. 


2. The form for which the data has to be aggregated.

We will need to also ask reporter to define the function at each form level


3. The aggregation functions for different form fields - summation of the weekly hours, average of some other field.

4. You can only choose a single root node for doing reports.


And currently the report can be pulled at one node level - report collected once cannot be added again - maybe later we define how to re-add the report data.


We shud be storing the result of doing all this in a table - if the user wishes to save the report

formReport

formId
aggregateFunction
rootNode

now we need 2 things:

1. hierarchyselector with a limit of only 1 and dont dont anything on pushing.

only 1 value needs to be added.


- will discuss later on and check




2. a form displayer and to ask for an aggregate function for each field.

glyphicons and font-awesome



Let's delete the tables and re-create them.


color scheme:


light-grey:#edeff0
black:#34495e
green:#10A8AB


maybe we should use sass.

in the React file:
import '!style-loader!css-loader!sass-loader!./../../scss/main.scss';



"css-loader": "^0.27.3"
"sass-loader": "^6.0.3"
"style-loader": "^0.14.0"


done.


creating a notification badge:



<div class="container">
  <button class="btn btn-default btn-lg btn-link" style="font-size:36px;">
    <span class="glyphicon glyphicon-comment"></span>
  </button>
  <span class="badge badge-notify">3</span>
</div>

.badge-notify{
 background:red;
 position:relative;
 top: -20px;
 left: -35px;
}



get a bell like this:

content: "\e123";

just move the color hover over notification:hover

count

1. action requireds - count this.
initialFormData[empId]


formId's from whichForms which are not in initialFormData




2. approval
done.

lets bring it in a menu.





now we can test with a fresh set of tables.



Lets take a backup of the existing code.



first we need 1 49% 49% width container 


<select onChange={this.loadForm} ref="formIndex">
            <option value="">Please choose a form to load</option>
            {formActionJsx}
          </select>



Lets do the same for approvals:
- so close.


finalShort.push({
            empId:v.empId,
            title:formStructure[v.formId].title,
            index:i
          })


Lets add a footer:

<div id="copyrights">
    <div class="container clearfix">
        <div class="col_half">
            <table class="st-a"><tbody><tr><td class="st-b"><a href="http://mytime.timeinc.net">Home</a></td><td class="st-b"><a href="mailto:corpcomm@timeinc.com">Contact Us</a></td><td class="st-c"><a href="http://emergency.mytime.timeinc.net/" target="_blank">Emergency Info</a></td></tr></tbody></table>                
        </div>
        <div class="col_half col_last tright">
            © 2014 Time Inc. All Rights Reserved.                
        </div>
    </div>
</div>


.st-a{position:relative; max-width:100%;
  tr {
    .st-b{
      padding: 0 5px;max-width:33%; border-right: 1px solid #AAAAAA;
    }
    .st-c{
      padding:0 5px;
    }
  }
}

#copyrights{
      background-color: #E5E5E5;
    border-top: 2px solid #3985c7;
    color: #333333;
    font-size: 12px;
    font-weight: 600;
    line-height: 20px;
    overflow: hidden;
    padding: 20px 30px;
    position: relative;
}


Lets make the admin circular buttons.

for admins the the main

We need to make a component for  the default '/' route

Lets call it 

Tasks

For an admin - tasks will be the circle of tasks and for a user it will be a blank component.


Now we can make circles out of the tasks and add them to tasks.



2 things:
1. front end and backend for the reports - 3 hours
2. if we create a form - we need to ask if he wants to push it directly and then load the push tab with the form loaded.




<Redirect to="hierarchySelect" push /> - inside Router to do an auto redirect

done.


Lets build a report demo.

We need clean tables first.
done.

Then 

1. work on ui of reports

1 single select menus  + for now we are supporting only addition for all fields.

or maybe if we choose a new value - we will replace the old value with the new value


2. work on backend of reports.


For a report - if we choose a node - we are always going to consider everyone till the leaf node - so we dont need the 2 checkboxes. It will always be everyone below - this - till the leaf nodes.


The lower drop downs also need to reflect the values based on the current selection.
done!


Now we can define the send object:

it will always be everyone below.


now write a backend recursive function for generating the report.


by default we will always go untill we reach the leaf node,

if a parent node has filled a specific form - we will also add in his own details.

Lets show them the org tree- along with the emp_id.

Then lets upload an excel for a simple form with 2 fields.

and see for a leaf if the upload works - yes it does.




for a report - we dont have to re-initialize anything - just show the calculated numbers.


{ '250': { '3': { 'Sum of hours this week': '40', approval: 'approved' } },
  '518': { '3': { 'Sum of hours this week': '30', approval: 'approved' } },
  '698': { '3': { 'Sum of hours this week': '42', approval: 'approved' } },
  '723': { '3': { 'Sum of hours this week': '35', approval: 'approved' } },
  '724': { '3': { 'Sum of hours this week': '39', approval: 'approved' } },
  '847': { '3': { 'Sum of hours this week': '38', approval: 'approved' } },
  '1129': { '3': { 'Sum of hours this week': '37', approval: 'approved' } },
  '1221': { '3': { 'Sum of hours this week': '29', approval: 'approved' } },
  '1274': { '3': { 'Sum of hours this week': '40', approval: 'approved' } } }




{ nodes: [ '70' ], formId: '3', aggregateFunction: 'sum' }






push form in the create form tab also - one link
My time theme for the application
footer same as myTime
History tab for all the users
UI for the table grid
for font - pet hero
text, label, upload(should always a option to download template option), checkbox
Add and update functionality separate



Next Tasks after this:

1. for previous forms - show in 2 col grid format.
2. add support for different aggregate functions in the form aggregation like:

average and string concatenation and boolean AND.

3. add support for cvs type fields with custom template - to be part of a form field and saving it
now




what we want to do:

The managaer may be pushed a form - which lets him fill a csv file as a field and then submit it and



When you create this field - you will need to specify a sample csv template - which will be sent to the children for filling.

so we will have to save the names of such csv's and store a separate variable in formStructure for rendering such fields.




3 things:

first: if the field is of type number - only then add it or do any maths.
done!


1. create support for defining separate functions for each field in a form.


2. modify the form creator - to add support for form based on 1 csv template.
Lets do this first.



we should save something in formsturcture:


so actually save the file and then write this to formstructure.


type:'csv',
title:'some-title',
pathToTemplate:'csv template file name'


lets see what the existing formStructure is:


[{"formId":1,"structure":{"title":"weekly status","type":"object","properties":{"Weekly Sum of hours":{"type":"string","title":"Weekly Sum of hours"},"Name":{"type":"string","title":"Name"}},"required":["Name","Weekly Sum of hours"]},"formName":"weekly status"}]




[  
   {  
      "formId":1,
      "structure":{  
         "title":"weekly status",
         "type":"object",
         "properties":{  
            "Weekly Sum of hours":{  
               "type":"string",
               "title":"Weekly Sum of hours"
            },
            "Name":{  
               "type":"string",
               "title":"Name"
            }
         },
         "required":[  
            "Name",
            "Weekly Sum of hours"
         ]
      },
      "formName":"weekly status"
   }
]


so we can save the form like this:

{
  formId:3,
  structure:{
    "title":"name of the form",
    "type":"csv",
    "csvTemplateName":'ldsjfljsdflkjsd.csv'
  }
}

so save this object in the formstructure table.

Lets check the formstructure table.




[{"formId":2,"structure":{"title":"some useful form","type":"csv","csvTemplateName":"/Users/joship/code/tii-dashboard/server-mvc/uploads/b03a2bdea436f79f9432f620837a9fba"}},{"formId":1,"structure":{"title":"weekly status","type":"object","properties":{"Weekly Sum of hours":{"type":"string","title":"Weekly Sum of hours"},"Name":{"type":"string","title":"Name"}},"required":["Name","Weekly Sum of hours"]},"formName":"weekly status"}]



[  
   {  
      "formId":2,
      "structure":{  
         "title":"some useful form",
         "type":"csv",
         "csvTemplateName":"/Users/joship/code/tii-dashboard/server-mvc/uploads/b03a2bdea436f79f9432f620837a9fba"
      }
   },


   {  
      "formId":1,
      "structure":{  
         "title":"weekly status",
         "type":"object",
         "properties":{  
            "Weekly Sum of hours":{
               "type":"string",
               "title":"Weekly Sum of hours"
            },
            "Name":{  
               "type":"string",
               "title":"Name"
            }
         },
         "required":[  
            "Name",
            "Weekly Sum of hours"
         ]
      },
      "formName":"weekly status"
   }
]

now 2 things:


1. pushing a form like this

2. fixing the preview - I think we can do this first.

maybe later we can store the actual fields structure and load it in UI
we will also remove the approval workflow for this - the values will simply be stored.

just send a isCsv flag to the backend service and we will make something different in formPublish


We will also have to see formPublish

once we push a csv form - check out formPublish


check now.

A quick idea: when the add is coming- mute the volume and then unmute it as soon as content starts


[{"formId":2,"isCsv":true,"empArray":["211","487","550","565","598","250","518","724","723","847","1129","1274","698","1221"]},
{"formId":1,"approval":true,"empArray":["211","487","550","565","598","250","518","724","723","847","1129","1274","698","1221"]}]



now modify the formpreview of employeeform.

if the type is csv - then create a button - which will do a post to download the respective csv.


we should save some data like an array of objects in formData and approval="approved" for that form.


Let's write some fixes - Maybe we do this tomorrow.




1. see if the report works correctly - for null sibling nodes.

lets backup the code and clear up the tables.

done!












the field object also has to be used



dont retrieve object.keys of something, lets use an aggregate function with the specific aggregate function.

so for this:

we will use:

{
  name:'concatenate',
  age:'add'
}

and pass this,



{ name: { type: 'string', title: 'name' },
  hours: { type: 'string', title: 'hours' } }



function summation(nodeArray, aggregateFunc) {
  let fieldSum = Object.keys(aggregateFunc);
  let x, y, buffer = {}, count, temp;
  for (y=0; y<fieldSum.length;y++) {
    if(fieldSum[y] !== 'approval') {
      buffer[fieldSum[y]] = 0;
      count = 0;
      for (x=0; x< nodeArray.length; x++) {
        if(nodeArray[x][fieldSum[y]) {
          temp = parseInt(nodeArray[x][fieldSum[y]]);
          buffer[fieldSum[y]] = buffer[fieldSum[y]] + (Boolean(temp)?temp:0); 
        }
      }
    }
  }
  return buffer;
}

sum 
or 
average


Let's try adding a null and a non-null node.
1
lets see the result of formData;


we need to add the fData

listening on port 8001
[{"empId":250,"fData":{"1":{"name":"x","hours":"40","approval":"approved"}}}]


lets delete the tables and do a new upload.



Let's take a backup of this code.
done.



tomorrow:

1. create a run dev script.
done!


minify bundle.js with webpack - do this first.
done!



Lets run a report at BU level and see what we get.
it's awesome now.


3. create support to run node-sum at BU level - this is failing badly.
done!




5. define differnt webpack.config.js for different environments
done!






7. save the template form with a .csv extension so that we dont have to mess around with it after it's downloaded.
done!






delete table and test.

now.
done!


The only problem is that we are averaging at each level - so is this fine??






local:
AWS.config.update({
  accessKeyId: "YOURKEY",
  secretAccessKey: "YOURSECRET",
  region: "sa-east-1",
  endpoint: new AWS.Endpoint('http://localhost:8000')
});

nodes are getting added multiple times 
why??


find only immediate


const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, '/uploads')
  },
  filename: function (req, file, cb) {
    cb(null, file.fieldname + '.csv');
  }
});



Let's test the csv pushing form feature.

lets delete the tables and test.

done!


remaining stuff (Enhancements)

1. store all the data- filled in csv form - next in formData

do this now!

When a normal form is filled, how is the data saved for 2 guys.
Let's check this out.


[  
   {  
      "empId":211,
      "fData":{  
         "2":{  
            "approver":"70",
            "comments":"approve",
            "Age":"33",
            "approval":"approved",
            "Name":"carl"
         }
      }
   },
   {  
      "empId":487,
      "fData":{  
         "2":{  
            "approver":"70",
            "comments":"approve",
            "Age":"12",
            "approval":"approved",
            "Name":"Sayantan"
         }
      }
   }
]


so based on this:


we can do something like this:


[ 
   {  
      "empId":211,
      "fData":{
         "2":{  
            "type":"csv",
            "headers":['h1','h2','h3']
            "data":[[1,2,3],[4,5,6]],
            "approval":"approved"
         }
      }
   }
]




So 

1. In view form in actions required - if u view a csv file and then go back to normal form view- csv is still shown.
in employee form - dont show approved forms

-fixed!




create a form - push it
create a csv form and push it


Enhancements:

2. for csv forms - write UI and service to upload the csv data against the user and formId.



5. if we set - no approval required - store the data directly with approval field as approved in formData - check and define approval workflows for normal and csv forms.

6. write UI and service to add roles to users, create a userRole table

Bugs:
1. in hierarchy screen- if u click on the notificaions, bu list gets added
fixed.

2. in hierarchy screen, if u choose only sepecific person - it throws error
- has to be fixed


3. fix the form view in upload data screen
done

4. if u push a form without approval - it doesnt increase the notification count - test this with empty tables
5. react warning in approval view.




checking if the approval workflows really work.


first for normal flows:


where is the approval field stored.



what is the value of publishform and formdata now.




[  
   {  
      "empId":211,
      "fData":{  
         "2":{  
            "approver":"70",
            "pehla":"first",
            "dusra":"second",
            "comments":"approve",
            "approval":"not-approved"
         }
      }
   }
]

[  
   {  
      "formId":2,
      "isCsv":false,
      "approval":true,
      "empArray":[  
         "211",
         "487",
         "550",
         "565",
         "598"
      ]
   },
   {  
      "formId":1,
      "isCsv":true,
      "empArray":[  
         "211",
         "487",
         "550",
         "565",
         "598"
      ]
   }
]




if a normal form is pushed without approval - it's data wont be directly saved.

create and push a normal form - and fill it's data- what happens



working correctly.




Lets test an approval flow and see if there any breaks













Role.
assign a role to people,
by default everybody is a user.

an admin can make people as admin.






How to make approval workflow for csv forms

1. store the "approval" field for csv forms in hierarchySelect

[  
   {  
      "formId":2,
      "isCsv":false,
      "approval":true,
      "empArray":[  
         "211",
         "487",
         "550",
         "565",
         "598"
      ]
   },
   {  
      "formId":1,
      "isCsv":true,
      "empArray":[  
         "211",
         "487",
         "550",
         "565",
         "598"
      ]
   }
]

Let's test:

1. push a csv form with and
2. without approval to yourself

and see the payload

what goes in formPublish.

{"type":"specific","nodes":["70"],"extras":[],"formId":"3","requireApproval":true,"isCsv":true}


{"type":"immediate-child","isBu":false,"nodes":["70"],"extras":[],"formId":"3","requireApproval":false,"isCsv":true}




2. write UI for uploading a csv 

lets test the backend params first
done.



fn = /Users/joship/code/tii-dashboard/server-mvc/uploads/1499856449592.csv formId = 3 empId = 487


so we will save something in formData




and storing data for non-approval based csv forms.





if approval cache is false or not-needed

[ 
   {  
      "empId":211,
      "fData":{
         "2":{
            "type":"csv",
            "headers":['h1','h2','h3']
            "data":[[1,2,3],[4,5,6]],
            "approval":"not-needed"
         }
      }
   }
]

else

[ 
   {  
      "empId":211,
      "fData":{
         "2":{  
            "type":"csv",
            "headers":['h1','h2','h3']
            "data":[[1,2,3],[4,5,6]],
            "approval":"sent-for-approval"
         }
      }
   }
]


read the csv and form the big object.


[ [ 'name', 'hours' ],
  [ 'Prabhas', '120' ],
  [ 'Ritika', '150' ],
  [ 'Neha', '130' ] ]




Let's delete everything and test a csv data upload for a cvs template form.


and then write the approval workflow and csv viewer

Let's scan - formData.

[{"empId":487,"fData":{"1":{"headers":["name","hours"],"type":"csv","data":[["x1","30"],["x2","40"],["x3","80"]],"approval":"not-needed"}}}]



and lets check what happens if we push a csv type with approval required.

[{"empId":211,"fData":{"undefined":{"headers":["name","hours"],"type":"csv","data":[["x1","30"],["x2","40"],["x3","80"]],"approval":"not-needed"}}},{"empId":487,"fData":{"1":{"headers":["name","hours"],"type":"csv","data":[["x1","30"],["x2","40"],["x3","80"]],"approval":"not-needed"}}}]

create a new csv template and push with an approval reqd.


[  
   {  
      "empId":211,
      "fData":{
         "undefined":{  
            "headers":[  
               "name",
               "hours"
            ],
            "type":"csv",
            "data":[  
               [  
                  "x1",
                  "30"
               ],
               [  
                  "x2",
                  "40"
               ],
               [  
                  "x3",
                  "80"
               ]
            ],
            "approval":"not-needed"
         }
      }
   },
   {  
      "empId":487,
      "fData":{  
         "1":{  
            "headers":[  
               "name",
               "hours"
            ],
            "type":"csv",
            "data":[  
               [  
                  "x1",
                  "30"
               ],
               [  
                  "x2",
                  "40"
               ],
               [  
                  "x3",
                  "80"
               ]
            ],
            "approval":"not-needed"
         },
         "2":{  
            "headers":[  
               "name",
               "hours"
            ],
            "type":"csv",
            "data":[  
               [  
                  "x1",
                  "30"
               ],
               [  
                  "x2",
                  "40"
               ],
               [  
                  "x3",
                  "80"
               ]
            ],
            "approval":"sent-for-approval"
         }
      }
   }
]



modify the approvals section:
done!


now to make approval and rejection work in case of csv -

lets clear the tables and do this.

Things remaining:

show approval status for csv forms in employee forms.

- check for the new formData in employee form and show appropriate message.

lets test this.


Rejected approvals from manager should create a notification count increase - this is fixed


3. do a better job with the holy grail layout overall, correct css for background images, 
move minified css to static folder - 
-  tomorrow



4. make / as the indexroute with accurate path checking so that tasks for admin is default view - tasks are shown everytime, if u choose something else - tasks will not be shown

next




BUG:
Warning: Unknown prop `on` on <li> tag. Remove this prop from the element. For details, see https://fb.me/react-unknown-prop


[ { hardCode: 1, adminList: [ '7', '12' ] } ]


Let's fix that bug-  if only specific people are pushed - it causes error.



Let's now test normal forms and csv forms ->


selectedFormIndex is undefined sometimes.


awesome!

Test 



Let the first time user also decide who will be an admin - by the same component.

send email after all 
form published to you 
or 
something sent for approval - send him a mail


- we will have to first test the AD account and send a mail via node js in AWS - if that works - we can write all the other code around it.



Contact: shreyans




3. lets reduce the size of bundle.js 
 later.



 Replicate a user from front-end

 dont set the email from backend.



 done!


 If there are no records present in the userDetail - show the firstTime
done.


Use database config from NODE_ENV
this.
done! 

setup email config to send mails.
create a file to store credentials.


so for all form publish - send mail to the test email 


- and for all approval 

1. when somebody fills a form and it goes for approval



so as far 

after user-replicating - set the path to '/' root.
done!
 


trigger approval mails on

if it follows the approval flow.
/updateFormdata
/postCsvTemplateData

Reall


asyncTask.push(callback => {
  docClient.update(updateSchema, (err, data) => {
    if(err)
      console.log('error in updating data' + JSON.stringify(err));
    else {
      console.log('formData updated successfully');
      dataCache.deleteCache('formDataMap');
      callback();
    }
  });
});

if(sendApprovalMail) {
  asyncTask.push(callback => {
    let mail = new ews.EmailMessage(exch);
    mail.Subject = ('Action required: Form submitted for your approval by ' + employeeMap[empId].fullName);
    mail.Body = new ews.TextBody('A form has been filled by '+employeeMap[empId].fullName+' is waiting your approval - Login to TII Dashboard to approve this');
    mail.ToRecipients.Add(testEmail);
    mail.Send().then(() => {
      callback();
    });
  });
}

async.parallel(asyncTask, function() {
  res.send("refresh-form-data-cache");
});




Lets test the csv flow for push and approval 
done!


only this remains:


2. define custom aggregation functions for all the form-fields - develope UI for this
- only this remains.





install ejs package in server-mvc in package.json as a dependency
in react - do hot reloading only in index.js only if env is dev-  how to do this with front end code.



in reports, bu dropdowns are getting created - set the arrays to [] onload




ultimate hack for passing multiple values
https://github.com/JedWatson/react-select/issues/155
onChange={(e) => this.handleSelect(item, e)}




onChange=this.handleSelect.bind(this, e)

onC.call(this, e, which) - this worked! 
use the event object as the main argument and the others



New set of enhancements:

3 types:

dont understand this requirement:

1. Admin should be able to activate and deactivate the Forms  - or edit the forms - in view forms screen.


2. The admin should have the ability to define the hierarchy of the employees in the tool and should be able to edit it. 

- We will only create the hierarchy from the csv data provided. There is no separate hierarchy


3. Define reminders Define reminders for the User when they miss out filling the data for a specific period.
- the user who has been pushed the form - sees a notification red icon with the different number of reminders and when he clicks on it - it loads the form to be filled



big ones
1. defining recurring form-pushing - defining the date range and the interval - and the making the form-push automatic.

2. Comment Trail  Comment trail should be maintained - not needed

3. report requirements - aggregation function should not be mandatory.


small ones

1. support for 
Number Boxes, Date Boxes, Dropdowns, Radio Buttons

2. Comments Box The admin should be able to write instructions or send a comment to the User while creating the Form.

3. By default, approval should be checked Yes.

4. The Admin should be able to define which all data sets should be aggregated to the next higher level. This could be done by a checkbox next to it. The aggregation could be Sum, Count, Average or Percentage.
This will help in Reporting of the aggregate data at the next higher up level. 

5. Embed validation for text fields and numerical values





Performance - Loading time when the application loads

The file which we download from Upload details tab should have csv format by default. (Right now we need to change after downloading)
done!


Check for any flag for the employees who have resigned – which we can use to show these employees at the end of table.
supply the flag

Upload Data – when select file for bulk upload - add a cvs template for the form selected - 
this is difficult.



edit and deletion of the forms created – this should be added in view forms tab

sequences of the form creation fields – the sequence in forms is not matching the fields sequence when they were created.
title instead of the form number in notification page
remove the forms which are filled from notification page – show them in reports history.
New report tab same page as click on notification – add another tab for user which can show the new forms to fill (same page which opens on clicking of notification icon)


In generate reports tab - form title should come instead of form numbers

In generate reports - selection of forms on top then the BU - Managers – employees under them
In generate reports - after selecting the forms have checkox for aggregation(options for sum, count, average, %) or the whole report with all data filled.


defining reporting dates - start and end date for the forms(when the form expires)


recurrence of the forms -  the form should be sent automatically after certain time phase to the people It was selected. (can also add delete people for the recurrence forms)
description before sending the forms - either in form or in the mail body
manager approval by default checked
define reminders - through mail



different fields in the create forms – also add radio buttons, dropdowns, Date boxes, number boxes, 
Let's do this

httpOptions: {
  agent: new https.Agent({
    rejectUnauthorized: true,
    keepAlive: true
  })
}




List of enhancements:

1. add order to fields in uischema
2. add a description field in create form

done!




3. use order of uischema always when rendering forms
done!






these 2:
4. while pushing forms - add an expiry date field - after which the form will not be considered.


5. in viewforms - add ui and service to delete a given form.
- add a delete form button

write a multiple form delete query.


npmCache.del('userDetails');
  npmCache.del('employeeMap');
  npmCache.del('allEmpIds');
  npmCache.del('publishForm');
  npmCache.del('userHierarchy');
  npmCache.del('buArray');
  npmCache.del('managerArray');
  npmCache.del('nestedMap');
  npmCache.del('formDataMap');
  npmCache.del('formStructure');
  npmCache.del('formStructureSQL');





for db performance- Let's code all the other features - then work on the performance.

we have to do this - figure out how to declare a docClient with this.

var dynamo = new AWS.DynamoDB({
  region: "ap-southeast-2",
  httpOptions: {
    agent: new https.Agent({
      rejectUnauthorized: true,
      keepAlive: true
    })
  }
});

also aws-sdk version:
^2.6.3


In old reports tab - show latest one on the top ->

always store the last_modified date - 
when form is pushed - store that date - when form is filled - store that date.


so in hierarchy select,

2 more options:

1. define expiry date for the push



2. define recurring for the form with :

a. start
b. end
c. recurring interval




in server app.js -lets do a cache test





var dynamo = new AWS.DynamoDB({
  region: "ap-southeast-2",
  httpOptions: {
    agent: new https.Agent({
      rejectUnauthorized: true,
      keepAlive: true
    })
  }
});

also aws-sdk version:
^2.6.3

var dynamo = new AWS.DynamoDB({
  region: "ap-southeast-2",
  httpOptions: {
    agent: new https.Agent({
      rejectUnauthorized: true,
      keepAlive: true
    })
  }
});

We may have to setup the project again:
http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_nodejs_express.html



production db:


fix the issue of loggin with npm - dont use nodemon in prod.


https://github.com/aws/aws-sdk-js/issues/671

save the expiry - and scan the table


[{"formId":1,"isCsv":false,"expiry":"Tue Aug 15 2017","approval":true,"empArray":["1276"]}]

how approvals will get affected by expiry I dont know.



doing a stable push and adding packages.

1.Fixing caching 

This is definitely not working.

We will need to take a different approach.


Test 2 things:

this has started working.
so let's delete some tables and test again.

done!




2. implementing recurring

how to do this - let's say we dont do approval workflows for it.

but we will have to support for csv type and normal type forms.


Let's start by storing the recurring part of it into a new table:

recurringFormPublish

if recurring form is selected- then we push to this new service instead of the old formpublish with the recurring information:


start date:
end date:

recurring interval: 
every day from the start date,
every week from the start date,
every month from the start date

now lets create a new table to store it in

publishFormRecurring

and we need to publish to a 

publishId - not a formId 

an int.


so we have now saved the recurring forms like this:


[  
  {  
    "formId":1,
    "isCsv":false,
    "actualRecurDays":[  
      "Wed Sep 13 2017"
    ],
    "expiryStart":"Wed Sep 13 2017",
    "empArray":[  
      "1276"
    ],
    "expiryEnd":"Wed Sep 13 2017",
    "interval":"everyweek",
    "publishId":2
  },
  {  
    "formId":1,
    "isCsv":false,
    "actualRecurDays":[  
      "Mon Sep 11 2017",
      "Tue Sep 12 2017",
      "Wed Sep 13 2017",
      "Thu Sep 14 2017"
    ],
    "expiryStart":"Mon Sep 11 2017",
    "empArray":[  
      "211",
      "487",
      "550",
      "565",
      "598",
      "1276"
    ],
    "expiryEnd":"Thu Sep 14 2017",
    "interval":"everyday",
    "publishId":1
  }
]

and data is stored like this:

[  
  {  
    "empId":1276,
    "fData":{  
      "1":{  
        "over 30":true,
        "last name":"Joshi",
        "comments":"store directly",
        "first name":"Prabhas",
        "approval":"not-needed"
      }
    }
  }
]

so for recurring, how should we save.


[  
  {
    "empId":1276,
    "fData":{  
      [publishId]:{
        'date-string1':{
          ...
        },
        'date-string2':{
          ...
        }
      }
    }
  }
]




3. changing reports




aim to make everything smaller
-remove graph packages, loading packages and 
re-use components
cleanup server code


"recurring"


Let's try this:


var dynamo = new AWS.DynamoDB({
  region: "ap-southeast-2",
  httpOptions: {
    agent: new https.Agent({
      rejectUnauthorized: true,
      keepAlive: true
    })
  }
});

also aws-sdk version:
^2.6.3





in db insertion functions- if something is empty-
make it a blank string.


when form is being submitted - do a check to make sure that formIndex is always present:


[  
  {  
    "empId":1276,
    "fData":{  
      "1":{  
        "checkIsReqd":true,
        "comments":" ",
        "textIsReed":"bhar",
        "textIsNotReqd":" ",
        "approval":"sent-for-approval"
      }
    }
  },
  {  
    "empId":211,
    "fData":{  
      "1":{  
        "checkIsReqd":true,
        "comments":" ",
        "textIsReed":"sdsdsd",
        "textIsNotReqd":" ",
        "approval":"sent-for-approval"
      }
    }
  },
  {  
    "empId":487,
    "fData":{  
      "1":{  
        "checkIsReqd":true,
        "comments":" ",
        "textIsReed":"bhar",
        "textIsNotReqd":" ",
        "approval":"sent-for-approval"
      },
      "undefined":{  
        "checkIsReqd":true,
        "comments":" ",
        "textIsReed":"le",
        "textIsNotReqd":" ",
        "approval":"not-needed"
      }
    }
  }
]


Lets complete the recurring form feature -


we need to :

also, we should send a publish date as part of the payload and then sort them by it.

in
1. show the recurring forms - normal or csv
2. store data
-done!







[  
  {  
    "formId":1,
    "isCsv":false,
    "actualRecurDays":[  
      "Wed Sep 13 2017"
    ],
    "expiryStart":"Wed Sep 13 2017",
    "empArray":[  
      "1276"
    ],
    "expiryEnd":"Wed Sep 13 2017",
    "interval":"everyweek",
    "publishId":2
  },
  {  
    "formId":1,
    "isCsv":false,
    "actualRecurDays":[  
      "Mon Sep 11 2017",
      "Tue Sep 12 2017",
      "Wed Sep 13 2017",
      "Thu Sep 14 2017"
    ],
    "expiryStart":"Mon Sep 11 2017",
    "empArray":[  
      "211",
      "487",
      "550",
      "565",
      "598",
      "1276"
    ],
    "expiryEnd":"Thu Sep 14 2017",
    "interval":"everyday",
    "publishId":1
  }
]


so for recurring, how should we save.

call it formDataRecurring

[  
  {
    "empId":1276,
    "fData":{  
      [publishId]:{
        'date-string1':{
          ...
        },
        'date-string2':{
          ...
        }
      }
    }
  }
]

so cache is like: 

{
  '1276':{
    [publishId]: {
      'date1':{

      },
      'date2':{

      }
    }
  }
}


recurForms:
Array[2]
0:
{…}
formId:
1
publishId:
"1"
1:
{…}
formId:
1
publishId:
"2"


now we need a function to update 


then:
1. change the notification number to reflect recurring dates.
done!

2. show old recurring forms in old reports and notification
done!





2. extend recurring for csv and check the flow.
now!






3. change the recurring set of people and dates.





4. show all forms in sorted order of publish date using lodash
5. remove vis and spinner dependency to reduce bundle.js size


if(!email){
      this.getUserData();
    } else {
      this.initialize(null);
    }

{
  recurKeys && recurKeys.map((v,i) => {
    var dateObj = Object.keys(recurFormData[v]);
    var formId = publishFormMap[v].formId;
    var schema = formStructure[formId];
    return (<div key={i}>
      {dateObj.map((v1,i1) => {
        var formData = recurFormData[v][v1];
        var classString = "pbl-"+v+"-"+(v1.getTime());
        return <div key={i1} class={"hide "+classString}>
          <Form schema={schema} formData={formData} uiSchema={uischema}><button type="submit" class="hide">Submit</button></Form>
        </div>;
      })}
    </div>);
  })
}



[  
  {  
    "formId":1,
    "isCsv":true,
    "publishDate":"Fri Sep 15 2017",
    "actualRecurDays":[  
      "Fri Sep 15 2017",
      "Sat Sep 16 2017"
    ],
    "publishId":1,
    "empArray":[  
      "1276"
    ]
  }
]



<li key={i} onClick={() => this.loadRecurring(v)}>{formMap[v.formId].title} - by recurring publish# {v.publishId}</li>

Now we can start working on csv features.



When submitting a csv file

for a normal csv how is it saved??




[{"empArray":["1144"],"isCsv":false,"publishDate":"Tue Sep 26 2017","expiry":"Wed Sep 20 2017","approval":true,"formId":3},{"empArray":["211","487","550","565","598","250","518","724","723","847","1129","1274","698","1221"],"isCsv":true,"publishDate":"Wed Sep 20 2017","expiry":"Wed Sep 20 2017","approval":true,"formId":2},{"empArray":["1276"],"isCsv":false,"publishDate":"Wed Sep 20 2017","expiry":"Wed Sep 20 2017","approval":true,"formId":1}]





2.5-  remove either name or title in form declaration.

3. reduce bundle.js size by removing jquery, spinner and 

chart display
done!




-now

lets test a little

so first goes jquery:

var formData = new FormData();
var imagefile = document.querySelector('#file');
formData.append("image", imagefile.files[0]);

axios.post('upload_file', formData, {
    headers: {
      'Content-Type': 'multipart/form-data'
    }
})


axios({
  method:'post',
  url: (localPathAppend+ "/postOrg"),
  data: data,
  headers: {
    'Content-Type': 'multipart/form-data'
  }
}).then((res) => {
  if(!email){
    this.getUserData();
  } else {
    this.initialize(null);
  }
}).catch((err) => {
  console.log(err);
})


$.ajax({
        method: "POST",
        url: (localPathAppend+ "/postOrg"),
        data: data,
        cache: false,
        processData: false,
        contentType: false
    }).then((res) => {
      if(!email){
        this.getUserData();
      } else {
        this.initialize(null);
      }
    }, (err) => {
      console.log(err) 
    });


Let's try to do a form submit without jquery




$.ajax({
        method: "POST",
        url: (localPathAppend+ "/postCsvTemplateData/"+selectedFormIndex+'/'+empId),
        data: data,
        cache: false,
        processData: false,
        contentType: false
      }).then((res) => {
        reInitializeData(selectedFormIndex);
      }, (err) => {
        console.log(err) 
      });




<div class="loading"></div>

all are done!
lets commit



1. create complete csv support - for recurrence

Let's do this.


how do we save the data.

this is the publish pojo.

[  
   {  
      "formId":1,
      "isCsv":true,
      "publishDate":"Tue Oct 10 2017",
      "actualRecurDays":[  
         "Tue Oct 10 2017",
         "Wed Oct 11 2017",
         "Thu Oct 12 2017"
      ],
      "publishId":1,
      "empArray":[  
         "1276"
      ]
   }
]

and for a csv - this is how it is saved.

[  
   {  
      "empId":1276,
      "fData":{ 
         "1":{  
            "headers":[  
               "fn1",
               "fn2",
               "fn3"
            ],
            "type":"csv",
            "data":[  
               [  
                  "1",
                  "2",
                  "3"
               ],
               [  
                  "4",
                  "5",
                  "6"
               ]
            ]
         }
      }
   }
]



[  
   {  
      "empId":1276,
      "fData":{  
         "2":{  
            "Tue Oct 10 2017":{  
               "name":"prabhas",
               "name_2":"joshi",
               "comments":"fillit"
            }
         }
      }
   }
]

since 1 publish id can be associated with only 1 formid, we can save it like this:

[  
   {  
      "empId":1276,
      "fData":{  
         "2":{ 
            "type":"csv",
            "headers":[  
               "fn1",
               "fn2",
               "fn3"
            ], 
            "Tue Oct 10 2017":[  
               [  
                  "1",
                  "2",
                  "3"
               ],
               [  
                  "4",
                  "5",
                  "6"
               ]
            ]
         }
      }
   }
]


and how is a recurring normal form saved.



published like this:

[  
   {  
      "formId":2,
      "isCsv":false,
      "publishDate":"Tue Oct 10 2017",
      "actualRecurDays":[  
         "Tue Oct 10 2017",
         "Wed Oct 11 2017",
         "Thu Oct 12 2017"
      ],
      "publishId":2,
      "empArray":[  
         "1276"
      ]
   },
   {  
      "formId":1,
      "isCsv":true,
      "publishDate":"Tue Oct 10 2017",
      "actualRecurDays":[  
         "Tue Oct 10 2017",
         "Wed Oct 11 2017",
         "Thu Oct 12 2017"
      ],
      "publishId":1,
      "empArray":[  
         "1276"
      ]
   }
]



[  
   {  
      "formId":2,
      "uiSchema":{  
         "ui:order":[  
            "name",
            "name_2"
         ]
      },
      "description":"simply fill it",
      "structure":{  
         "title":"normal-flow",
         "type":"object",
         "properties":{  
            "name":{  
               "type":"string",
               "title":"name"
            },
            "name_2":{  
               "type":"string",
               "title":"name_2"
            }
         },
         "required":[  
            "name",
            "name_2"
         ]
      },
      "formName":"normal-flow"
   },
   {  
      "formId":1,
      "structure":{  
         "title":"csv-checker",
         "type":"csv",
         "csvTemplateName":"/Users/joship/code/tii-dashboard/server-mvc/uploads/1507644052832.csv"
      }
   }
]


[ [ 'fn1', 'fn2', 'fn3' ], [ '1', '2', '3' ], [ '4', '5', '6' ] ]

Let's test the create and update



2. support radio button - with main text and label-radio pairs - store and display, and checkbox

will come to know after meeting.







3. change the publish appending and getting form publishing accordingly.

[  
   {  
      "formId":1,
      "isCsv":true,
      "publishDate":"Thu Oct 12 2017",
      "actualRecurDays":[  
         "Thu Oct 12 2017",
         "Fri Oct 13 2017",
         "Sat Oct 14 2017"
      ],
      "publishId":1,
      "empArray":[  
         "1276"
      ]
   }
]

saved like :

{  
   "1276":{  
      "1":{  
         "headers":[  
            "fn1",
            "fn2",
            "fn3"
         ],
         "Thu Oct 12 2017":[  
            [  
               "1",
               "2",
               "3"
            ],
            [  
               "4",
               "5",
               "TRUE"
            ]
         ],
         "type":"csv",
         "Fri Oct 13 2017":[  
            [  
               "5",
               "6",
               "7"
            ],
            [  
               "Prabhas",
               "TRUE",
               "TRUE"
            ]
         ]
      }
   }
}


                      {v.csv && <PlaindataGrid data={v.formData.data} headers={v.formData.headers} />}

                      {isCsv && <PlaindataGrid data={formData} headers={formData.headers} />}


Now we need to test


1. normal flows - are they working 
in case of rejection - is the data getting erased - 

is he getting comments box to comment why is he rejecting - 

he is getting a read-only comment field 
- so maybe we can add a new comment field and then re-set it, 
and the old data is also erased - lets initialize it with the rejected data
- this is a new feature and we will write it in weekend.




2. csv flows - approval and rejection and saving
this is good.



3. recurring - normal 
good

and csv
done!



6. try to include some more fields like radio and number or date.


Add suport for New fields:

radio button list
checkbox list
number only
textarea


so basically - save a uischema in formStructure


so delete formStructure also and start fresh

<span class="glyphicon glyphicon-remove"></span>





So this is how we are going to do this:


1. save a checkbox list and diplay it to user
2. save a radio button list and show to user.

3. see how we can store the saved data

later on we add required/not-required checks









const schema2 = {
      type:"object",
      properties:{
        "radioR2":{
          "type": "object",
          "required": [
            "radioR"
          ],
          "properties": {
            "radioR": {
              "type": "string",
              "title": "Title of radio button",
              "enum": [
                "Radio value 1",
                "Radio value 2",
                "Radio value 3"
              ]
            }
          }
        }
      }
  };

  const uiSchema2 = {
      "radioR2":{
        "radioR": {
          "ui:widget": "radio"
        }        
      }
    };

    const formData2 = {
      "radioR2":{"radioR":"Radio value 2"}
    }


    final:






{  
   "formName":"filled",
   "description":"filled",
   "structure":{  
      "title":"filled",
      "type":"object",
      "properties":{  
         "checkbox0":{  
            "type":"array",
            "title":"t-shirt size",
            "items":{  
               "type":"string",
               "enum":[  
                  "small",
                  "medium",
                  "large"
               ]
            },
            "uniqueItems":true
         }
      },
      "required":[  

      ]
   },
   "immediatePush":false,
   "uiSchema":{  
      "ui:order":[  
         "checkbox0"
      ],
      "checkbox0":{  
         "ui:widget":"checkboxes"
      }
   }
}


in approvals- uischema is not applied as a whole.
BUGfix - fixed




Design a new approve-reject-main comment system for a form - store them and show them separately.

after rejection - user can't fill??

why is uischema coming as ui:disabled:true in get request.
some cache will have to be cleared -


I want to take a backup of this entire thing.
done


1. append publish audience

now - if a new set of properties are set approval, expiry - with different audience and same formId -
it will apply the 2 properties to the entire set.
done!

[{"formId":1,"isCsv":false,"publishDate":"Fri Oct 13 2017","expiry":"na","approval":true,"empArray":["211"]}]


and later on we can add a check to see if the formdata filling date and compare it with publish date and let him fill it again if required.
later.







4. show ui:order in older filled forms and show form name instead of #1, #2
done!

5. see if we can check that bug - after rejection of a form - the cache for formData gives ui:disabled = true



2. add separate user-comment and approver-comment and show both where anything is non empty now.

have 2 fields: 
user_comment, approver_comment in formData


first we see why in rejection, form data is getting erased- and try to preserve that.


3. preserve the data when rejecting and show it along with the comment



{  
      "empId":550,
      "fData":{  
         "1":{  
            "approver":"70",
            "comments":"reject this",
            "first name":"Subra",
            "checkbox1":{  
               "checkbox12":"medium"
            },
            "approval":"not-approved",
            "checkbox2":[  
               "1",
               "2",
               "3"
            ]
         }
      }
   }

Lets see if we  can get a partial ui:disabled via formTest




so, we have to save :


userComment
approverComment

dont let create csv forms without a formName.


this.setState({
      submitting:true
    }, () => {
      axios.post(localPathAppend+'/setFormStructure', payload)
      .then((res) => {
        loadImmediate = res.data.pushImmediate;
        this.setState({
          submitting:false,
          fieldArray:[],
          current:0,
          formType:"normal"
        }, () => {
          this.refs.formName.value = "";
          if(payload.immediatePush){
            requestFormStructure(loadImmediate);
          } else {
            requestFormStructure();
          }
        });
      },(err) => {
        console.log(err);
      }); 
    })

I got it.

so this works - lets do this everywhere.
on all the getters
 and lets also change the axios request to catch.



 The first step is to make the ui code always use the latest cache.
 the second step is make the server as fast as possible by doing the minimum number of calculations.
 and maybe use a different cache/ and try some performance boosts listed in online articles.


BUG: -
when a csv form is added to reports, it's name is not shown.

lets re-create it in local.


when a csv form is saved - it's formName prop is not set - so lets set it
fixed




I wanna write a new report service which is essentially a combine all rows - so lets just use a new post action

so:

1. can we create a csv in server side, populate it with data and send a sendFile - test this.
now!

2. write a combine function which will work for csv forms (add BU,empId etc) and normal form and convert the big json blob into csv rows
 - maybe we can try to combine the recurring rows and add a date field


3. collect relevant input from report screen




when you get the response of the filename

create a get request like this:

window.location.href = "/ControllerName/DownloadAsCSV?json=" + jsonStr;








So we've got to change the caching layer - instead of deleting and rebuilding the cache, we will return the new cache which will be set in parent component.

do this only for formStructure - and then see what happens.




Let's take a fresh backup of the entire codebase.
done.


start with this.


then 
https://gist.github.com/scr1p7ed/ee0d96c3795e59244063
try to increase the heapsize in pm2.
this is the command
pm2 start app --node-args="--max-old-space-size=6144"


also, for max-id - we will keep an internal variable - which will be incremented every time
we will never delete a formId - we will always set the expire flag to true

by default - all forms will pass expiry
later.


Let's push these changes - purge the tables and see the performance boost.



when the server starts for the first time - all cache will be built.
done


memcached-elasticache npm


how to clear chrome's application cache.




toggleNotification:false,
            loadImmediateForm:null,
            firstTime:false,
            defaultPath:false


done!


Now let's start writing the local versions of other getters


first: publishCsvForm

featurewise - i want to add archive forms and do a test flow and also add deletion of fields

and the major stable build.


Then once i test it tomorrow- I can show it to abdul.

Then from tomorrow, we start with reports and roles








publishFormRecurring


BUG: in recurring push to yourself, action required - fields are coming as disabled - check later
fixed

also, if 2 cache are closely related -
lets write a big cache building function instead of small ones - so that we do the scan once for each table - not more than 6 times.



also, 






to avoid all cahing:

https://stackoverflow.com/questions/20429592/no-cache-in-a-nodejs-server

do this.




res.header('Cache-Control', 'private, no-cache, no-store, must-revalidate');


addAdmin


implement delete forms.
done!

test a flow with a pushed form and then expire it.
done!



now, deleting a form field.

maybe- later - addin null OR blank field values check in form builder

also when filling the csv form - show the description




instead of this, lets create a new map -
which store - whether this field is to be counted or not.
khatam.

dont let him submit with an empty field name - later




do an overall scan only once- see if 2 caching functions are doing a scan of the same table.


Next role implementation:


a user will see the default 3 tabs.

a reporter will see the default 3 tabs and the generate report tab

an admin will see all tabs


do caching for roles also,

in the roles drop drop down- 

initialize will all the existing admins and reporters.

for caching, let's use this kind of an object:

[  
   {  
      "pk":1,
      "role":{  
         "user":[ 1 ],
         "admin":[ 2 ],
         "reporter":[ 3 ]
      }
   }
]




we should create a table called roles which should store the above object

now everytime we update this table

changing the role object should run a local setRoleLocal function with the new rolecache.


and how will we tackle when new people are added.


for reports - we will generate the csv file and then display and link to download the csv file


only set admins and reporters.


if someone is both reporter and admin -

he is an admin


roles is done!



Everything else is done. Only reports remain:




Next steps:

1. when you send a recurring publish form - send a text along with it - that will help us pick up when we run reports.


every one of these texts will be the basis of our recurring reports

So in reports:

1st drop down you choose is:

type of report:

1. normal => give him a list of normal and csv forms

2. recurring => give him a list of all the recurring titles



in approval - formInquestion is not being passed to parent function- check later

when doing data uploads to form - dont read/write cache multiple times, write into an object and then iterate over the object and write into the cache once.

build cache minimaly - just 1 select * for all tables

add the new frequency for recurring



So,

in hierarchy select -

add a recurring label to be used later 


just generate a csv report - from the cvs report - use excel to combine:

<div class="margin-top-15">
                <select ref="agg" class="form-control">
                  <option value="sum">Sum Aggregate of all fields</option>
                  <option value="average">Average Aggregate all fields</option>
                </select>
              </div>


  {
        !submitting && resultOfReport && <div>
        <div>Results of report summation report at level {isBu?reportNode:employeeMap[reportNode].fullName}</div>
          <ul>
            {reportResultJSX}
          </ul>
        </div>
      }


Now the main thing is the we will generate a csv file and then ask them to download the csv with the data

how to do this.


so the return value of that will be the name of the csv




now the wrapper report logic is done - we need to start writing the core report logic for the 4 types of reports


extra fields that you want to add to the report:
done!






so, first we decide the headers


Then the audience - copy from publish action logic


and the
type - normal, recurring
and isCsv






{
211: {
2: {
approver: "70",
f1: "filled",
userComment: "reject",
approval: "approved"
},
3: {
f1: "test 1",
userComment: "approve",
f3: 12,
approval: "not-needed"
}
},
550: {
3: {
f1: "something",
userComment: "approve",
f3: 24,
approval: "not-needed"
}
}
}


add userComment and approverComment and approval status to reports



second thing is how do we get the values of radio buttons and checkboxes.

so Lets delete everything ->

and see how the checkbox or radio button data is actually stored.

while creating headers - we need to get the field name

Let's try to save formData in recurring.
done!







{
211: {
1: {
textbox field: "My name is carl",
userComment: "approve",
checkbox1: {
checkbox12: "radio 2"
},
approval: "not-needed",
checkbox2: [
"check 1",
"check 2",
"check 3"
]
},
2: {
headers: [
"fn1",
"fn2",
"fn3"
],
type: "csv",
data: [
[
"1",
"2",
"3"
],
[
"4",
"2",
"5"
],
[
"6",
"TRUE",
"Prabhas"
]
],
approval: "not-needed"
}
}


 - it shows an extra line:




Also fix the duplicate cahing methods


if nothing is selected in reporter - then reporter roles get null
let's fix this


else {
      
    }

done!


now let's fix the repeated caching.




dataCache.formStructureCache(), 
dataCache.findMaxFormId(), 
dataCache.buildNestedMap(), 
dataCache.queryPublish(), 
dataCache.findMaxPublishId(), 
dataCache.queryPublishRecurring(), 
dataCache.buildFormdataCache(), 
dataCache.buildFormdataRecurringCache(), 
dataCache.queryUsers(), 
dataCache.getHierarchy(), 
dataCache.queryRole()

done!




Since this form does not require an approval - your csv data has been saved directly - before hand without loading any form
Fix later.

dunno when this is happening.2



for a user whose manager is undefined - we cant imitate that person
Major bug - check later



in case of multiple  approvals sent to a singe manager - it fails with some error-  recreate in local and then push a fix.
fixed-  push this.
done!





for a user whose manager is undefined - we cant imitate that person
Major bug - check later



vr mall, phoenix mall


order the fields in forms.
Simple - from ui order.





recuring form data reports are not coming -
check



on normal or recurring change ->






dont create preview as a function.
the function will take values from the normal and form and then create the preview 


Changes:
include comments in reports
done!


include last filled date of data filled in reports
done - for normal -


last modified date for csv form push - normal


remove tree view from profile list
done


make action required as default tab instead of old reports
done!


Form13.PDF

/userForm


userComment: "appro",
approverComment: " ",


Let's test


delete everything.

now when you update formdata, include lastModified


(new Date()).toDateString()

for recurring forms-  u dont need to add the date field -coz it's already there.


adding intervals:

 monthly, 
 quarterl - 3 months from now, 
 half-yearly - 6 months



 <option value="monthly">Every month from start data</option>
                <option value="quarterly">Quarterly from start date</option>
                <option value="halfYearly">Half yearly from start date</option>